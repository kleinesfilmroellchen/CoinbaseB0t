//! LALRPOP grammar for a modified version of SPC700 assembly.
//! Note that this grammar can not parse plain SPC700 assembly, as it is not LR(1).

use miette::{SourceOffset, SourceSpan};
use lalrpop_util::ParseError;

use std::sync::{Weak, Arc};
use std::cell::RefCell;

use crate::parser::{
	instruction::{Instruction, Mnemonic, Number, AddressingMode, Opcode},
	Environment,
	LabelUsageKind, 
	Token,
	Register,
	label::{Label, LocalLabel, MacroParent},
	try_make_direct_page_addressing_mode,
	source_range,
	program::ProgramElement,
};
use crate::mcro::{MacroSymbol, Macro, MacroValue};
use crate::error::AssemblyError;
use crate::AssemblyCode;

grammar<'env, 'src>(environment: &'env Arc<RefCell<Environment>>, source_code: &'src Arc<AssemblyCode>);

pub Program: Vec<ProgramElement> = "\n"* <line:( <Line> )*> => line;

Line: ProgramElement = <label:( <LabelForInstruction> "\n"* )?> <element:InstructionOrMacro> <newlines:("\n"+)> => 
	element.set_label(label).extend_span(newlines[0].into());

InstructionOrMacro: ProgramElement = {
	InstructionWithTestComment => ProgramElement::Instruction(<>),
	Macro => ProgramElement::Macro(<>),
	<mcro:"include"> <file:"string"> => ProgramElement::IncludeSource {
		file: String::from_utf8_lossy(&file.0).to_string(),
		span: source_range(mcro.into(), file.1.into()),
		label: None,
	},
	MacroCall => <>,
};

MacroCall: ProgramElement = <start:"%"> <macro_name:"identifier"> "(" <arguments:Comma<Number>?> <end:")"> => ProgramElement::UserDefinedMacroCall {
	macro_name: macro_name.0,
	arguments: arguments.unwrap_or(Vec::new()),
	span: source_range(start.into(), end.into()),
	label: None
};

InstructionWithTestComment: Instruction = <mut instruction:Instruction> <expected:";="?> => {
	#[cfg(test)]
	if let Some(expected) = expected {
		instruction.expected_value = Some(expected.0);
		instruction.span = source_range(instruction.span.into(), expected.1.into());
	}
	instruction
};

Instruction: Instruction = {
	<mnemonic:Mnemonic> <first_operand:AddressingMode> <second_operand:( "," <AddressingMode> )?> => Instruction {
		opcode: Opcode {
			mnemonic: mnemonic.0,
			first_operand: Some(first_operand),
			second_operand,
			force_direct_page: mnemonic.1,
		},
		span: mnemonic.2,
		..Instruction::default()
	},
	<mnemonic:Mnemonic> => Instruction {
		opcode: Opcode {
			mnemonic: mnemonic.0,
			first_operand: None,
			second_operand: None, 
			force_direct_page: mnemonic.1,
		},
		span: mnemonic.2,
		..Instruction::default()
	},
};

// The boolean specifies whether this instruction is forced to direct page addressing.
Mnemonic: (Mnemonic, bool, SourceSpan) = {
	<mnemonic:"mnemonic"> => (mnemonic.0, false, mnemonic.1),
	<mnemonic:"mnemonic"> <b:".b"> => (mnemonic.0, true, source_range(mnemonic.1.into(), b.into())),
};

Macro: Macro = {	
	<data_macro:TableMacro> <numbers:NumberList> => Macro {
		value: MacroValue::Table {
			values: numbers,
			entry_size: match data_macro.0 {
				MacroSymbol::Byte | MacroSymbol::Db => 1,
				MacroSymbol::Dw | MacroSymbol::Word => 2,
				MacroSymbol::Dl => 3,
				MacroSymbol::Dd => 4,
				_ => unreachable!(),
			},
		},
		span: data_macro.1,
		label: None,
	},
	<mcro:"org"> <address:Number> =>? Ok(Macro {
		value: MacroValue::Org(address.try_value(mcro, source_code.clone()).map_err(|err| ParseError::User {
			error: AssemblyError::LabelsInMacroArgument {
				mcro: MacroSymbol::Org,
				src: source_code.clone(),
				location: mcro,
				// TODO: reintroduce when numbers have source locations
				// argument_location: address.source_span(),
			},
		})?),
		span: mcro,
		label: None,
	}),
	<mcro:"brr"> <filename:"string"> => Macro {
		value: MacroValue::Brr(String::from_utf8_lossy(&filename.0).into_owned()),
		span: source_range(mcro.into(), filename.1.into()),
		label: None,
	},
	<mcro:"ascii"> <text:"string"> => Macro {
		value: MacroValue::String { text: text.0, has_null_terminator: false },
		span: source_range(mcro.into(), text.1.into()),
		label: None,
	},
	<mcro:"asciiz"> <text:"string"> => Macro {
		value: MacroValue::String { text: text.0, has_null_terminator: true },
		span: source_range(mcro.into(), text.1.into()),
		label: None,
	},
	<mcro:"incbin"> <text:"string"> <range:InclusionRange?> => Macro {
		value: MacroValue::Include {
			file: String::from_utf8_lossy(&text.0).into_owned(),
			range,
		},
		span: source_range(mcro.into(), text.1.into()),
		label: None,
	},
	"end" => Macro {
		value: MacroValue::End,
		span: <>,
		label: None,
	},
	"pushpc" => Macro {
		value: MacroValue::PushSection,
		span: <>,
		label: None,
	},
	"pullpc" => Macro {
		value: MacroValue::PopSection,
		span: <>,
		label: None,
	},
	ArchMacro,
	LabelAssignment,
	UserDefinedMacro,
};

TableMacro: (MacroSymbol, SourceSpan) = {
	"db" => (MacroSymbol::Db, <>),
	"byte" => (MacroSymbol::Db, <>),
	"dw" => (MacroSymbol::Dw, <>),
	"word" => (MacroSymbol::Dw, <>),
	"dl" => (MacroSymbol::Dl, <>),
	"dd" => (MacroSymbol::Dd, <>),
};

ArchMacro: Macro = <mcro:"arch"> <arch:"identifier"> =>? {
	let architecture = arch.0;
	if ["spc700", "spc700-raw"].contains(&&*architecture) {
		environment.borrow().report_or_throw(AssemblyError::ArchitectureMacroIgnored {
			src:      source_code.clone(),
			location: source_range(mcro.into(), arch.1.into()),
		}).map_err(|error| ParseError::User { error: *error }).map(|_| Macro::default())
	} else {
		Err(AssemblyError::InvalidArchitectureMacro {
			arch:     architecture,
			src:      source_code.clone(),
			location: source_range(mcro.into(), arch.1.into()),
		}).map_err(|error| ParseError::User { error })
	}
};

UserDefinedMacro: Macro = <start:"macro"> <name:"identifier"> <arguments:UserDefinedMacroArguments?> "\n" <body:Program> <end:"endmacro"> => Macro {
	value: MacroValue::UserDefinedMacro {
		name: name.0,
		arguments: Arc::new(RefCell::new(MacroParent::Formal(arguments.unwrap_or(Vec::new())))),
		body,
	},
	span: source_range(start.into(), end.into()),
	label: None,
};

UserDefinedMacroArguments: Vec<(String, SourceSpan)> = {
	"(" <Comma<"identifier">> ")" => <>,
	"," <Comma<"identifier">> => <>,
};

NumberList = Comma<Number>;

/// Allows both vasm and asar syntax; note that asar requires an end point.
/// vasm: `, start [, length]`
/// asar: `: start - end`
InclusionRange: SourceSpan = {
	<comma:","> <start:Number> <length:( "," <Number> )?> =>? {
		let start = usize::try_from(start.try_value(comma.into(), source_code.clone()).map_err(AssemblyError::from)?)
			.map_err(|err| AssemblyError::from_number_error(err, comma.into(), source_code.clone()))?;
		let length = usize::try_from(length.map(|length| length.try_value(comma.into(), source_code.clone())).transpose()
				.map_err(AssemblyError::from)?.unwrap_or(i64::MAX))
			.map_err(|err| AssemblyError::from_number_error(err, comma.into(), source_code.clone()))?;
		Ok((start, length).into())
	},
	<colon:":"> <start:Number> <dash:"-range-"> <end:Number> =>? {
		let colon_dash_range = source_range(colon.into(), dash.into());
		let start = usize::try_from(start.try_value(colon_dash_range, source_code.clone())
				.map_err(AssemblyError::from)?)
			.map_err(|err| AssemblyError::from_number_error(err, colon.into(), source_code.clone()))?;
		let end = usize::try_from(end.try_value(colon_dash_range, source_code.clone())
				.map_err(AssemblyError::from)?)
			.map_err(|err| AssemblyError::from_number_error(err, colon.into(), source_code.clone()))?;
		if start > end {
			Err(ParseError::User { error: AssemblyError::StartAboveEnd {
				start,
				end,
				src: source_code.clone(),
				location: source_range(colon.into(), dash.into()),
			}})
		} else {
			Ok((start, end - start).into())
		}
	},
};

LabelForInstruction: Label = {
	"." <identifier:"identifier"> ":" => Label::Local(
		// Create a new local label that might be merged in the future.
		Arc::new(RefCell::new(LocalLabel {
			name: identifier.0.clone(),
			location: None,
			span: identifier.1,
			// Don't rely on forward-to-backward parsing order; we can't know the parent label here.
			parent: Weak::new(),
		}))
	),
	<identifier:"identifier"> ":" => Label::Global(environment.borrow_mut().get_global_label(&identifier.0, identifier.1, LabelUsageKind::AsDefinition)),
};

Label: Label = {
	<dot:"."> <identifier:"identifier"> => Label::Local(Arc::new(RefCell::new(LocalLabel {
		name: identifier.0.clone(),
		location: None,
		span: source_range(dot.into(), identifier.1.into()),
		// Don't rely on forward-to-backward parsing order; we can't know the parent label here.
		parent: Weak::new(),
	}))),
	<identifier:"identifier"> => Label::Global(environment.borrow_mut().get_global_label(&identifier.0, identifier.1, LabelUsageKind::AsAddress)),
	<start:"<"> <identifier:"identifier"> <end:">"> => Label::MacroArgument {
		name: identifier.0,
		span: source_range(start.into(), end.into()),
		macro_parent: Arc::new(RefCell::new(MacroParent::Formal(Vec::new()))),
		value: None,
	}
};

LabelAssignment: Macro = <mut label:Label> <eq:"="> <value:Number> => {
	label.set_location(value.clone());
	Macro {
		value: MacroValue::AssignLabel { label: label.clone(), value },
		span: source_range(label.source_span().into(), eq.into()),
		label: None,
	}
};

Number: Number = {
	<lhs:Factor> "+" <rhs:Factor> => Number::Add(Box::new(lhs), Box::new(rhs)),
	<lhs:Factor> "-" <rhs:Factor> => Number::Subtract(Box::new(lhs), Box::new(rhs)),
	Factor,
};

Factor: Number = {
	<lhs:Factor> "*" <rhs:Term> => Number::Multiply(Box::new(lhs), Box::new(rhs)),
	<lhs:Factor> "/" <rhs:Term> => Number::Divide(Box::new(lhs), Box::new(rhs)),
	Term,
};

Term: Number = {
	"number" => Number::Literal(<>.0),
	"+" <Term>,
	"-" <Term> => Number::Negate(Box::new(<>)),
	"(" <Number> ")",
	Label => Number::Label(<>),
};

AddressingMode: AddressingMode = {
	<Number> => try_make_direct_page_addressing_mode(<>, AddressingMode::DirectPage, AddressingMode::Address),
	"#" <Number> => AddressingMode::Immediate(<>),
	"A" => AddressingMode::Register(Register::A),
	"X" => AddressingMode::Register(Register::X),
	"Y" => AddressingMode::Register(Register::Y),
	"SP" => AddressingMode::Register(Register::SP),
	"PSW" => AddressingMode::Register(Register::PSW),
	"YA" => AddressingMode::Register(Register::YA),
	"C" => AddressingMode::CarryFlag,
	<Number> "+X" => try_make_direct_page_addressing_mode(<>, AddressingMode::DirectPageXIndexed, AddressingMode::XIndexed),
	<Number> "+Y" => try_make_direct_page_addressing_mode(<>, AddressingMode::DirectPageYIndexed, AddressingMode::YIndexed),
	"[" <Number> "+X" "]" => try_make_direct_page_addressing_mode(<>, AddressingMode::DirectPageXIndexedIndirect, AddressingMode::DirectPageXIndexedIndirect),
	"[" <Number> "]" "+Y" => try_make_direct_page_addressing_mode(<>, AddressingMode::DirectPageIndirectYIndexed, AddressingMode::DirectPageIndirectYIndexed),
	<Number> "." <"number"> =>? try_make_direct_page_addressing_mode((<>),
		|(a, b)| Ok(AddressingMode::DirectPageBit(a, AddressingMode::check_bit(b.0 as u8, b.1, &source_code)?)),
		|(a, b)| Ok(AddressingMode::AddressBit(a, AddressingMode::check_bit(b.0 as u8, b.1, &source_code)?))),
	"/" <address:Number> "." <bit:"number"> =>? Ok(AddressingMode::NegatedAddressBit(address, AddressingMode::check_bit(bit.0 as u8, bit.1, &source_code)?)),
	"[" "X" "]" "+" => AddressingMode::IndirectXAutoIncrement,
	"[" "X" "+" "]" => AddressingMode::IndirectXAutoIncrement,
	"[" "X" "]" => AddressingMode::IndirectX,
	"[" "Y" "]" => AddressingMode::IndirectY,
};

Comma<T>: Vec<T> = {
	<mut v:(<T> ",")*> <e:T> => {
		v.push(e);
		v
	}
};

/// Lexer API information so that LALRPOP uses the spcasm lexer found in lexer.rs
extern {
	/// We provide this from the Token information.
	type Location = usize;
	type Error = AssemblyError;

	enum Token {
		"identifier" => Token::Identifier(<String>, <SourceSpan>),
		"mnemonic" => Token::Mnemonic(<Mnemonic>, <SourceSpan>),
		"A" => Token::Register(Register::A, <SourceSpan>),
		"X" => Token::Register(Register::X, <SourceSpan>),
		"Y" => Token::Register(Register::Y, <SourceSpan>),
		"+X" => Token::PlusRegister(Register::X, <SourceSpan>),
		"+Y" => Token::PlusRegister(Register::Y, <SourceSpan>),
		"SP" => Token::Register(Register::SP, <SourceSpan>),
		"PSW" => Token::Register(Register::PSW, <SourceSpan>),
		"YA" => Token::Register(Register::YA, <SourceSpan>),
		"C" => Token::Register(Register::C, <SourceSpan>),
		"org" => Token::Macro(MacroSymbol::Org, <SourceSpan>),
		"db" => Token::Macro(MacroSymbol::Db, <SourceSpan>),
		"byte" => Token::Macro(MacroSymbol::Byte, <SourceSpan>),
		"dw" => Token::Macro(MacroSymbol::Dw, <SourceSpan>),
		"word" => Token::Macro(MacroSymbol::Word, <SourceSpan>),
		"dl" => Token::Macro(MacroSymbol::Dl, <SourceSpan>),
		"dd" => Token::Macro(MacroSymbol::Dd, <SourceSpan>),
		"ascii" => Token::Macro(MacroSymbol::Ascii, <SourceSpan>),
		"asciiz" => Token::Macro(MacroSymbol::Asciiz, <SourceSpan>),
		"incbin" => Token::Macro(MacroSymbol::Incbin, <SourceSpan>),
		"include" => Token::Macro(MacroSymbol::Include, <SourceSpan>),
		"end" => Token::Macro(MacroSymbol::End, <SourceSpan>),
		"brr" => Token::Macro(MacroSymbol::Brr, <SourceSpan>),
		"pushpc" => Token::Macro(MacroSymbol::Pushpc, <SourceSpan>),
		"pullpc" => Token::Macro(MacroSymbol::Pullpc, <SourceSpan>),
		"arch" => Token::Macro(MacroSymbol::Arch, <SourceSpan>),
		"macro" => Token::Macro(MacroSymbol::Macro, <SourceSpan>),
		"endmacro" => Token::Macro(MacroSymbol::EndMacro, <SourceSpan>),
		"number" => Token::Number(<i64>, <SourceSpan>),
		"string" => Token::String(<Vec<u8>>, <SourceSpan>),
		"#" => Token::Hash(<SourceOffset>),
		"," => Token::Comma(<SourceOffset>),
		"+" => Token::Plus(<SourceOffset>),
		"*" => Token::Star(<SourceOffset>),
		"-" => Token::Minus(<SourceOffset>),
		"-range-" => Token::RangeMinus(<SourceOffset>),
		"/" => Token::Slash(<SourceOffset>),
		"(" => Token::OpenParenthesis(<SourceOffset>),
		")" => Token::CloseParenthesis(<SourceOffset>),
		"[" => Token::OpenIndexingParenthesis(<SourceOffset>),
		"]" => Token::CloseIndexingParenthesis(<SourceOffset>),
		"<" => Token::OpenAngleBracket(<SourceOffset>),
		">" => Token::CloseAngleBracket(<SourceOffset>),
		"%" => Token::Percent(<SourceOffset>),
		":" => Token::Colon(<SourceOffset>),
		"." => Token::Period(<SourceOffset>),
		".b" => Token::ExplicitDirectPage(<SourceSpan>),
		"=" => Token::Equals(<SourceOffset>),
		"\n" => Token::Newline(<SourceOffset>),
		// Do this once/if LALRPOP supports it
		// #[cfg(test)]
		";=" => Token::TestComment(<Vec<u8>>, <SourceSpan>),
	}
}
