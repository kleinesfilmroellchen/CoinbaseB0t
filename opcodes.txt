7. CPU ORGANIZATION.

A Sony SPC700 series is used in the CPU core of the SFX sound source.
it is possible to access and address space of 64K bytes in the SPC
series CPU. Address classification of the memory space is made
according to purpose: and addresses 0000 - 00ff are called page 0
and addresses 0100 - 01ff are called page 1.
In regard to the data in this region, when direct page designation
is carried out by direct page flag (P) within the program status
word, it is possible to carry out data processing in wide-ranging
addressing modes with a small number of cycles.

Within the CPU there are the universal registers A,X and Y, program
status word (PSW) of the various flags, program counter (PC), and
stack pointer (SP).

The A register is operable by the greatest number of commands,
and becomes and 8-bit operation accumulator. When 16-bit 
operations are carried out, it becomes paired with Y register
and becomes the lower lever 8-bit register of the 16-bit
accumulator.
The X and Y registers, in addition to their function as universal
registers, are used in various operations, such as the function
as index register of various index addressing modes, the function
as dual-address command source, destination address register, etc.

In the command set there are single address commands which carry
out arithmetic and logical operations centered in the A register
and dual address commands which can designate random address
within the direct page as source address and destination addresses.

In regard to bit processing diversified by control purpose. Boolean
bit operation commands are applicable to the 8K byte range of
data of addresses 0000 - 1fff. Moreover, in regard to the bits
within the total space of the 64K bytes, commands of multiple bit
test and set, test and reset are provided for. For the purpose of
data which must be systematized or in order to carry out data
processing rapidly. It is possible to operate 16-bit data with a
single command. Addition, subtraction, comparison and transference
are possible between two byte of continuous 16-bit data within the
direct page and the paired Y register and A register. In addition
increment and decrement of continuous 16-bit data within the
direct page are possible.

There are multiplication and division commands for the purpose
of rapid data processing and processing of data ina variety of
forms. Multiplication is 8-bit x 8-bit with no sign and is
carried out with the multiplicand stored in the Y register and
the multiplier stored in the A register; the result is entered
into the Y, A 16-bit accumulator. Division is 16bits/8bits with
no sign and carried out with the dividend stored in the Y, A 16
bit accumulator and the divisor stored in the X register : the
resulting quotient is entered into the A register and the
remainder is entered intro the Y register.
In the processing of decimal data, there are decimal (addition,
subtraction) correcting commands in regard to the results of
both addition and subtraction.

In regard to branched commands, there are relative branched
commands according to the conditions of the various status
flags, branched commands according to the conditions of set
or reset of random bits with the direct page, etc. In addition,
in regard to looped branched commands, there are comparison
branched commands and subtraction branched commands, and for
these there are two types of addressing modes.

In regard to subroutine call commands, there are subroutine
address direct designation three-byte call commands within
the 64K bytes. two-byte call commands for calling subroutines
of specific areas, and 16 portion one-byte call commands using
call table: it is possible to improve byte efficiency through
proper usage in response to the frequency of subroutine use.



1. CPU REGISTERS


Withing the CPU are the registers necessary for the execution of
the various commands. These are an A register (note : functions
as an 8-bit accumulator). X register, Y register (8-bit universal
register which can also be used as index register). PSW ( program
status word). SP (stack pointer), etc. These are all 8-bit 
registers but the PC (program counter) is made up of 16 bits.


------------------------------
            P|C               |   Program Counter      (16 bits)
------------------------------
              ----------------
             |        A       |   A Register           (8  bits)
              ----------------
------------------------------
      Y      |        A       |   (Y,A Paired 16-bit Accumulator)
------------------------------                         (16 bits)
              ----------------
             |        X       |   X Register           (8  bits)
              ----------------
              ----------------
             |        Y       |   Y Register           (8  bits)
              ----------------
              ----------------
             |       SP       |   Stack Pointer        (8  bits)
              ----------------
              ----------------
             |       PSW      |   Program Status Word  (8  bits)
              ----------------
            /              /
           ---------------
          |N|V|P|-|H|-|Z|C|
           ---------------

           N = Negative Flag
           V = Overflow Flag
           P = Direct Page Flag
           H = Half Carry Flag
           Z = Zero Flag
           C = Carry Flag (Bit Accumulator)



(1) A REGISTER

This register is used as an 8-bit accumulator.
At times of 16-bit operation commands. it becomes a register for
retaining low byte data in the 16-bit accumulator made up of this
paired with the Y register. When operation commands are issued, it
becomes the multiplier register and low byte data of the product is
entered. When division commands are issued, paired with the Y register
it formulates the dividend and the resulting quotient is entered.

(2) X REGISTER

In addition to its role as a universal data register, it also
functions as an index register when index addressing is being
carried out. In addition, it is also used as a two-address command
destination address register and X register indirect address register.
In division commands, it becomes the divisor register.


(3) Y REGISTER

In addition to its role as a universal data register, it also functions
as an index register when index addressing is being carried out, In
addition, it is also used as a two-address command source address
register.
When carrying out 16-bit operation commands, it becomes the register
which retains the high byte data of the 16-bit accumulator which is
made up of the pairing of this with the A register. When
multiplication commands are being carried out, it becomes the dividend
register and the product high byte data is entered.
When carrying out division commands, paired with the A register it
formulates the dividend, and the resulting remained is entered.

(4) PROGRAM COUNTER (PC)

The program counter is made up of 16 bits and has an address region
of 64K bytes. The upper level 8 bits are called PCH and the lower
level 8 bits are referred to as PCL-
Normally, it would have the address to be executed next and would
be incremented only the number of bytes necessary fo the command
fetched.
When there is a branching command in the midst of the program the address
of the branch destination would be stored in the program counter. When
there is a reset (negative POR) input, reset vector which are in
addresses FFFF and FFFE enter respectively PCH and PCL and branching
takes place.


(5) STACK POINTER (SP)

The stack pointer is used to send data to RAM or to recover from
RAM when subroutine call, push (PUSH), pop (POP), or return (RET)
commands are being carried out. The address region indicated by
the stack pointer is within page 1 (addresses 0100-01ff)


15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
--------------------------------------
 0  0  0  0  0  0 0 1|   SP Values    |
--------------------------------------
 Fixed by Hardware     Determined by the Program.



When sending data to RAM, the stack pointer decreases by one
after sending data (post decrement) and increases by one prior
to restoring data (pre-increment).
The diversified activities of the stack pointer are summarized below:

SUB-ROUTINE CALLS

        --------------------------------------------------------
       |Stack Address|    Activity     |  SP Value after sending|
        --------------------------------------------------------
       |    SP       |  sending to PCH |       SP-1             |
       |    SP-1     |  sending to PCL |       SP-2             |
        --------------------------------------------------------


RESTORING FROM SUB-ROUTINE

        --------------------------------------------------------
       |Stack Address|    Activity     |  SP Value after sending|
        --------------------------------------------------------
       |    SP+1     |  sending to PCH |       SP+1             |
       |    SP+1     |  sending to PCL |       SP+2             |
        --------------------------------------------------------

To send to A register, X register, Y register, PSW to and from
the stack, the commands PUSH and POP can be used.

PUSH A (X,Y, PSW)

        ---------------------------------------------------------
       |Stack Address|    Activity      |  SP Value after sending|
        ---------------------------------------------------------
       |    SP       |sending of A (X..)|       SP-1             |
        ---------------------------------------------------------

POP A (X,Y, PSW)

        ---------------------------------------------------------
       |Stack Address|    Activity      |  SP Value after sending|
        ---------------------------------------------------------
       |    SP+1     |sending of A (X..)|       SP+1             |
        ---------------------------------------------------------

(6) PROGRAM STATUS WORD (PSW)

The program status word is made up of the various flags which are
set and reset according to the results of the execution of 8-bit
register commands and the various flags which determine the
activities of the CPU. When reset it becomes "000-0-00".

    7    6     5     4     3     2     1     0
  -----------------------------------------------
 |   N    V     P     -     H     -     Z     C  |
  ----------------------------------------------

Carry Flag (C).

After operation execution, this is set when there has been a carry
from the uppermost bit of the arithmetic logic unit (ALU) or when
there has been no borrow. It is even altered with shift or rotate
commands. It also acts as an bit accumulator of Boolean bit operation
commands. It is set at the SETC commands and reset at the CLRC commands.
In addition, the carry flag inverts at the NOTC commands.

Zero Flag (Z)

Alter operation execution, this flag is set when the result is
zero and is reset whens the result is not zero. Even with 16-bit
operation commands, zero detection is carried out. It is possible
to carry out tests with conditional branching commands.

Half Carry Flag (H)

After operation execution, this flag is set when there has been
a carry from from bit 3 of the ALU to bit 4, or when there has
not been any borrow. There is no command to set, however, it is
reset by reset by means of the CLRV command. At his time, the
overflow flag is also set.

Direct Page Flag (P)

This is the flag which designates the direct page to which many
addressing mode are applicable, such as direct page addressing
etc. When 0, the direct page becomes the addresses of the
region 0000-00ff and when 1, it becomes the addresses of the
region 0100-01ff. It is set by the STEP command and reset by the
CLRP command.

Overflow Flag (V).

After arithmetic operation execution, this flag is set when
overflow or underflow has been produced. At this time, influence
is extended simultaneously to the H flag.
It is possible to carry out tests with conditional branching 
commands.

Negative Flag (N)

After operation execution, this flag is set when the values of
the result of MSD is 1 and reset when that values is 0. It is
possible to carry out tests with conditional branching commands.

7.2. MEMORY SPACE.

It is possible for the Sound-CPU to address 64K bytes of memory.
Memory space is divide up according to purpose. From address
0000, 512 bytes are divided into two pages of 256-bytes units,
called zero page and page one. It is possible to access data
within these regions by means of numerous address modes, such
as direct page addressing, etc.
Page one is taken up by the stack.


7.2.1. Direct Pages (Zero Page, Page One)

By means of setting or resetting the direct page (P) flag
within the program status word. it is possible to designate 
whether zero page or page one is to be made the direct page.
it is set up such that the data within this page can be treated
with fewer bytes, at higher speed and with more numerous types
of commands and addressing modes.

   Stack Area
   ----------

   The stack region is established in the RAM region within page
   one. The uppermost byte of the stack address is fixed at 01.
   The lowermost byte of the stack address must be given its
   initial setting by the program.

7.2.2. Uppermost Page

Internal ROM Region

A mask ROM is installed within the Sound-CPU from FFC0H- FFFF. There
is a program in it which transmits data from the ROM cassette to the
256K bit RAM through the SCPU. This region is used by means of reset.

7.2.3. Area of Applicable Bit Operation Commands.

(i)   The commands SET1 (set memory bit) and CLR1 (clear memory bit)
      are applicable to one-bit data with the direct page.

(ii)  The commands TSET1 (test and set bit) and TCLR1 ( test and
      clear bit) are applicable to the total 64K byte region.

(iii) The Boolean operation commands (AND1, OR1, EOR1, MOV1, NOT1)
      are applicable to the 8K byte region of 0000 - 1FFF.


        Fig. 7.2.3. Region of Applicable Bit Operation Commands.

     ----------------------------------------------------------
0000 |  |             |   |                |     |             |
     |  |  SET1, CLR1 |   | AND1,OR1,EOR1, |     | TSET1,TCLR1 |
     |  |  applicable |   | MOV1,NOT1      |     |             |
     |  |  to direct  |   |                |     |             |
00FF |  |  page.      |   |                |     |             |
     |  |             |   |                |     |             |
     |  |             |   |                |     |             |
     |  |             |   |                |     |             |
     |  |             |   |                |     |             |
01FF |   -------------    |                |     |             |
     |                    |                |     |             |
     |                    |                |     |             |
     |                    |                |     |             |
     |                    |                |     |             |
     |                    |                |     |             |
     |                    |                |     |             |
1FFF |                    ------------------     |             |
     |                                           |             |
     |                                           |             |
     |                                           |             |
     |                                           |             |
     |                                           |             |
     |                                           |             |
7FFF |                                            -------------
     |                                           |             |
     |                                           |  Unusable   |
FFBF |                                           |             |
FFC0 |                                            -------------
     |                                           |             |
     |                                           |   IPL-ROM   |
     |                                           |             |
FFFF |                                           |             |
     ----------------------------------------------------------


7.2.4. Direct Page Addressing

Since all of the addressing modes indicated in Table 7.2.4 are
applicable to the data of the direct page (P=0: addresses 
0000-00FF P=1: address 0000 - 01FF) designated by the direct page
(P) flag. it is possible to manipulate the data in various ways.
In addition byte efficiency also improves due to the fact that
direct address designation is possible by one-byte data within
the command words. Moreover, since effective command cycles also
decrease data can be accessed more rapidly.


        Table 7.2.4. Memory Access Addressing Effective Address

--------------------------------------------------------------------
                                        #of   Effective Addr. Region
Symbol  |    Addressing    
                                        Bytes  0000-01FF  1FFF >1FFF
--------------------------------------------------------------------
  dp       Direct Page                    2        X        X

  dp+X     X-Indexed Direct Page          2        X        X

  dp+Y     Y-Indexed Direct Page          2        X        X

  (X)      Indirect                       1        X        X

  (X)+     Indirect Auto-increment        1        X        X

  dp,dp    Direct Page to D.P.            3        X        X

  (X),(Y)  Indirect Page to I.P.          1        X        X

  dp Inm   Immediate Data to D.P.         3        X        X

  dp, bit  Direct Page Bit                2        X        X

dp,bit,rel Direct Page Bit Relative       3        X        X

 mem, bit  Absolute Boolean Bit           3        X        X     
                                                   
   labs    Absolute                       3        X        X     X

  labs+X   X-indexed Absolute             3        X        X     X

  labs+Y   Y-indexed Absolute             3        X        X     X

  (dp+X)   X-indexed Indirect             2        X        X     X

  (dp)+Y   Indirect Y-indexed Indirect    2        X        X     X

--------------------------------------------------------------------

9. SUMMARY OF SPC700 COMMANDS.

An SPC700 series is used for the SFX sound source CPU. However,
standby and sleep modes can not be used.

The command set operand notation and explanation of command activity
are indicated in the table below. The upper portion of the table are
symbols necessary to operand description. These are symbols necessary
assembler description. In the lower portion of the table, the values
of the various operand are expressed as symbols. Assembler 
descriptions are given as numerical values or labels.

Table 9.1. Command Operand Symbols and Meaning

Symbol
-----------------------------------------------
  A       A register
  X       X register
  Y       Y register
 PSW      Program status word
 YA       Y, A paired 16-bit register
 PC       Program counter
 SP       Stack pointer

 ( )      Indirect expression
( )+      Indirect auto-increment expression
  #       Immediate data
  |       Absolute address
  /       Bit reversal
  .       Bit position indicator
 ( )      Indexed Indirect expression
  H       Hexadecimal notation
------------------------------------------------
 inm      8-bit immediate data
 dp       Offset address within direct page
 abs      16-bit absolute address
 rel      Relative offset complement value of 2
 mem      Boolean bit operation address
 bit      Bit location


          MSB

  X       -----------------------
          | | | | |0|           |
          -----------------------
          \----X----/


          MSB

  Y       -----------------------
          | | | | |1|           |
          -----------------------
          \----Y----/

upage     Offset within U page
  n       Vector call number.


In giving an explanation of operations, in addition to the notations
and symbols above, the following symbols are also used.

Table 9.2. Symbols and Meaning of Operation Explanation


Symbol      Meaning
---------------------------------------
  N        Negative flag
  V        Overflow flag
  P        Direct page flag
  B        Break flag
  H        Half carry flag
  I        Indirect master enable flag
  Z        Zero flag
  C        Carry flag

  +        Addition
  -        Subtraction
  :        Comparison
 AND       Logic product
  OR       Logic sun
 EOR       Exclusive logic sun
  *        Multiplication
  /        Division

  Q        Division quotient
  R        Division remainder
 (d)       Destination
 (S)       Source
 ---       Direction of data transmission
 - -       Data decrement
 + +       Data increment
 < <       1 bit shift left
 > >       1 bit shift right
------------------------------
Note : The number of cycles of conditional branching commands are
appropriate to cases when there is no branching to the left side 
and when there is branching to the right side.

Table 9.3.  Explanation of Symbols in the Status Flag Column

-----------------------------------------------
 Symbol         Meaning
-----------------------------------------------
  .          No change
  0          Cleared to 0
  1          Set to 1
Flag name    Set or cleared depending on result
-----------------------------------------------


1. 8-bit Data Transmission Commands. Group I

------------------------------------------------------------------------
Mnemonic  Operand  Code Bytes Cycles Operation                    Flag
------------------------------------------------------------------------
  MOV    A, #inm    E8    2     2     A <- inm                  N......Z
  MOV    A, (X)     E6    1     3     A <- (X)                  N......Z
  MOV    A, (X)+    BF    1     4     A <- (X) with auto inc    N......Z
  MOV    A, dp      E4    2     3     A <- (dp)                 N......Z
  MOV    A, dp+X    F4    2     4     A <- (dp+X)               N......Z
  MOV    A, labs    E5    3     4     A <- (abs)                N......Z
  MOV    A, labs+X  F5    3     5     A <- (abs+X)              N......Z
  MOV    A, labs+Y  F6    3     5     A <- (abs+Y)              N......Z
  MOV    A, (dp+X)  E7    2     6     A <- ((dp+X+1)(dp+X))     N......Z
  MOV    A, (dp)+Y  F7    2     6     A <- ((dp+1)(dp)+Y)       N......Z
  MOV    X, #inm    CD    2     2     X <- inm                  N......Z
  MOV    X, dp      F8    2     3     X <- (dp)                 N......Z
  MOV    X, dp+Y    F9    2     4     X <- (dp+Y)               N......Z
  MOV    X, labs    E9    3     4     X <- (abs)                N......Z
  MOV    Y, #inm    8D    2     2     Y <- inm                  N......Z
  MOV    Y, dp      EB    2     3     Y <- (dp)                 N......Z
  MOV    Y, dp+X    FB    2     4     Y <- (dp+X)               N......Z
  MOV    Y, labs    EC    3     4     Y <- (abs)                N......Z
------------------------------------------------------------------------

2. 8-BIT DATA TRANSMISSION COMMANDS. GROUP 2.

------------------------------------------------------------------------
Mnemonic  Operand  Code Bytes Cycles Operation                    Flag
------------------------------------------------------------------------
  MOV    (X),A      C6    1     4     A -> (X)                  ........
  MOV    (X)+,A     AF    1     4     A -> (X) with auto inc    ........
  MOV    dp,A       C4    2     4     A -> (dp)                 ........
  MOV    dp+X,A     D4    2     5     A -> (dp+X)               ........
  MOV    labs,A     C5    3     5     A -> (abs)                ........
  MOV    labs+X,A   D5    3     6     A -> (abs+X)              ........
  MOV    labs+Y,A   D6    3     6     A -> (abs+Y)              ........
  MOV    (dp+X),A   C7    2     7     A -> ((dp+X+1)(dp+X))     ........
  MOV    (dp)+Y,A   D7    2     7     A -> ((dp+1)(dp)+Y)       ........
  MOV    dp,X       D8    2     4     X -> (dp)                 ........
  MOV    dp+Y,X     D9    2     5     X -> (dp+Y)               ........
  MOV    labs,X     C9    3     5     X -> (abs)                ........
  MOV    dp,Y       CB    2     4     X -> (dp)                 ........
  MOV    dp+X,Y     DB    2     5     X -> (dp+X)               ........
  MOV    labs,Y     CC    3     5     X -> (abs)                ........
------------------------------------------------------------------------

3. 8-BIT DATA TRANSMISSION COMMANDS, GROUP 3.

------------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                    Flag
------------------------------------------------------------------------
  MOV    A, X        7D    1     2     A <- X                   N......Z
  MOV    A, Y        DD    1     2     A <- Y                   N......Z
  MOV    X, A        5D    1     2     X <- A                   N......Z
  MOV    Y, A        FD    1     2     Y <- A                   N......Z
  MOV    X, SP       9D    1     2     X <- SP                  N......Z
  MOV    SP, X       BD    1     2    SP <- X                   ........
  MOV    dp(d),dp(s) FA    3     5    (dp(d)) <- (dp(s))        ........
  MOV    dp,#inm     8F    3     5    (dp) <- inm               ........
------------------------------------------------------------------------

4. 8-BIT ARITHMETIC OPERATION COMMANDS.

------------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                    Flag
------------------------------------------------------------------------
  ADC    A,#inm      88    2     2     A <- A+inm+C            NV..H..ZC
  ADC    A,(X)       86    1     3     A <- A+(X)+C            NV..H..ZC
  ADC    A,dp        84    2     3     A <- A+(dp)+C           NV..H..ZC
  ADC    A,dp+X      94    2     4     A <- A+(dp+X)+C         NV..H..ZC
  ADC    A,labs      85    3     4     A <- A+(abs)+C          NV..H..ZC
  ADC    A,labs+X    95    3     5     A <- A+(abs+X)+C        NV..H..ZC
  ADC    A,labs+Y    96    3     5     A <- A+(abs+Y)+C        NV..H..ZC
  ADC    A,(dp+X)    87    2     6     A <- A+((dp+X+1)(dp+X)) NV..H..ZC
  ADC    A,(dp)+Y    97    2     6     A <- A+((dp+1)(dp)+Y)   NV..H..ZC
  ADC    (X),(Y)     99    1     5   (X) <- (X)+(Y)+C          NV..H..ZC
  ADC    dp(d),dp(s) 89    3     6 (dp(d))<-(dp(d))+(dp(s))+C  NV..H..ZC
  ADC    dp,#inm     98    3     5  (dp) <- (dp)+inm+C         NV..H..ZC
------------------------------------------------------------------------
  SBC    A,#inm      A8    2     2     A <- A-inm-!C           NV..H..ZC
  SBC    A,(X)       A6    1     3     A <- A-(X)-!C           NV..H..ZC
  SBC    A,dp        A4    2     3     A <- A-(dp)-!C          NV..H..ZC
  SBC    A,dp+X      B4    2     4     A <- A-(dp+X)-!C        NV..H..ZC
  SBC    A,labs      A5    3     4     A <- A-(abs)-!C         NV..H..ZC
  SBC    A,labs+X    B5    3     5     A <- A-(abs+X)-!C       NV..H..ZC
  SBC    A,labs+Y    B6    3     5     A <- A-(abs+Y)-!C       NV..H..ZC
  SBC    A,(dp+X)    A7    2     6  A <- A-((dp+X+1)(dp+X))-!C NV..H..ZC
  SBC    A,(dp)+Y    B7    2     6  A <- A-((dp+1)(dp)+Y)-!C   NV..H..ZC
  SBC    (X),(Y)     B9    1     5   (X) <- (X)-(Y)-!C         NV..H..ZC
  SBC    dp(d),dp(s) A9    3     6 (dp(d))<-(dp(d))-(dp(s))-!C NV..H..ZC
  SBC    dp,#inm     B8    3     5  (dp) <- (dp)-inm-!C        NV..H..ZC
------------------------------------------------------------------------
  CMP    A,#inm      68    2     2     A-inm                   N......ZC
  CMP    A,(X)       66    1     3     A-(X)                   N......ZC
  CMP    A,dp        64    2     3     A-(dp)                  N......ZC
  CMP    A,dp+X      74    2     4     A-(dp+X)                N......ZC
  CMP    A,labs      65    3     4     A-(abs)                 N......ZC
  CMP    A,labs+X    75    3     5     A-(abs+X)               N......ZC
  CMP    A,labs+Y    76    3     5     A-(abs+Y)               N......ZC
  CMP    A,(dp+X)    67    2     6     A-((dp+X+1)(dp+X))      N......ZC
  CMP    A,(dp)+Y    77    2     6     A-((dp+1)(dp)+Y)        N......ZC
  CMP    (X),(Y)     79    1     5     (X)-(Y)                 N......ZC
  CMP    dp(d),dp(s) 69    3     6     (dp(d))-(dp(s))         N......ZC
  CMP    dp,#inm     78    3     5     (dp)-inm                N......ZC
  CMP    X,#inm      C8    2     2     X-inm                   N......ZC
  CMP    X,dp        3E    2     3     X-(dp)                  N......ZC
  CMP    X,labs      1E    3     4     X-(abs)                 N......ZC
  CMP    Y,#inm      AD    2     2     Y-inm                   N......ZC
  CMP    Y,dp        7E    2     3     Y-(dp)                  N......ZC
  CMP    Y,labs      5E    3     4     Y-(abs)                 N......ZC
------------------------------------------------------------------------

5. 8-BIT LOGIC OPERATION COMMANDS.

------------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                    Flag
------------------------------------------------------------------------
  AND    A,#inm      28    2     2     A <- A AND inm           N......Z.
  AND    A,(X)       26    1     3     A <- A AND (X)           N......Z.
  AND    A,dp        24    2     3     A <- A AND (dp)          N......Z.
  AND    A,dp+X      34    2     4     A <- A AND (dp+X)        N......Z.
  AND    A,labs      25    3     4     A <- A AND (abs)         N......Z.
  AND    A,labs+X    35    3     5     A <- A AND (abs+X)       N......Z.
  AND    A,labs+Y    36    3     5     A <- A AND (abs+Y)       N......Z.
  AND    A,(dp+X)    27    2     6  A <- A AND ((dp+X+1)(dp+X)) N......Z.
  AND    A,(dp)+Y    37    2     6   A <- A AND ((dp+1)(dp)+Y)  N......Z.
  AND    (X),(Y)     39    1     5   (X) <- (X) AND (Y)         N......Z.
  AND    dp(d),dp(s) 29    3     6 (dp(d))<-(dp(d)) AND (dp(s)) N......Z.
  AND    dp,#inm     38    3     5  (dp) <- (dp) AND inm        N......Z.
------------------------------------------------------------------------
  OR     A,#inm      08    2     2     A <- A OR inm            N......Z.
  OR     A,(X)       06    1     3     A <- A OR (X)            N......Z.
  OR     A,dp        04    2     3     A <- A OR (dp)           N......Z.
  OR     A,dp+X      14    2     4     A <- A OR (dp+X)         N......Z.
  OR     A,labs      05    3     4     A <- A OR (abs)          N......Z.
  OR     A,labs+X    15    3     5     A <- A OR (abs+X)        N......Z.
  OR     A,labs+Y    16    3     5     A <- A OR (abs+Y)        N......Z.
  OR     A,(dp+X)    07    2     6  A <- A OR ((dp+X+1)(dp+X))  N......Z.
  OR     A,(dp)+Y    17    2     6   A <- A OR ((dp+1)(dp)+Y)   N......Z.
  OR     (X),(Y)     19    1     5   (X) <- (X) OR (Y)          N......Z.
  OR     dp(d),dp(s) 09    3     6 (dp(d))<-(dp(d)) OR (dp(s))  N......Z.
  OR     dp,#inm     18    3     5  (dp) <- (dp) OR inm         N......Z.
------------------------------------------------------------------------
  EOR    A,#inm      48    2     2     A <- A EOR inm           N......Z.
  EOR    A,(X)       46    1     3     A <- A EOR (X)           N......Z.
  EOR    A,dp        44    2     3     A <- A EOR (dp)          N......Z.
  EOR    A,dp+X      54    2     4     A <- A EOR (dp+X)        N......Z.
  EOR    A,labs      45    3     4     A <- A EOR (abs)         N......Z.
  EOR    A,labs+X    55    3     5     A <- A EOR (abs+X)       N......Z.
  EOR    A,labs+Y    56    3     5     A <- A EOR (abs+Y)       N......Z.
  EOR    A,(dp+X)    47    2     6  A <- A EOR ((dp+X+1)(dp+X)) N......Z.
  EOR    A,(dp)+Y    57    2     6   A <- A EOR ((dp+1)(dp)+Y)  N......Z.
  EOR    (X),(Y)     59    1     5   (X) <- (X) EOR (Y)         N......Z.
  EOR    dp(d),dp(s) 49    3     6 (dp(d))<-(dp(d)) EOR (dp(s)) N......Z.
  EOR    dp,#inm     58    3     5  (dp) <- (dp) EOR inm        N......Z.
------------------------------------------------------------------------

6. ADDITION & SUBTRACTION COMMANDS.

------------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
------------------------------------------------------------------------
  INC      A         BC    1     2      ++ A                  N......Z.
  INC      dp        AB    2     4      ++ (dp)               N......Z.
  INC     dp+X       BB    2     5      ++ (dp+X)             N......Z.
  INC     labs       AC    3     5      ++ (abs)              N......Z.
  INC      X         3D    1     2      ++ X                  N......Z.
  INC      Y         FC    1     2      ++ Y                  N......Z.
-----------------------------------------------------------------------
  DEC      A         9C    1     2      -- A                  N......Z.
  DEC      dp        8B    2     4      -- (dp)               N......Z.
  DEC     dp+X       9B    2     5      -- (dp+X)             N......Z.
  DEC     labs       8C    3     5      -- (abs)              N......Z.
  DEC      X         1D    1     2      -- X                  N......Z.
  DEC      Y         DC    1     2      -- Y                  N......Z.
-----------------------------------------------------------------------

7. SHIFT, ROTATION COMMANDS

------------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
------------------------------------------------------------------------
  ASL      A         1C    1     2      C << A      <<0       N......ZC
  ASL      dp        0B    2     4      C << (dp)   <<0       N......ZC
  ASL     dp+X       1B    2     5      C << (dp+X) <<0       N......ZC
  ASL     labs       CC    3     5      C << (abs)  <<0       N......ZC
-----------------------------------------------------------------------
  LSR      A         5C    1     2      0 >> A      <<C       N......ZC
  LSR      dp        4B    2     4      0 >> (dp)   <<C       N......ZC
  LSR     dp+X       5B    2     5      0 >> (dp+X) <<C       N......ZC
  LSR     labs       4C    3     5      0 >> (abs)  <<C       N......ZC
-----------------------------------------------------------------------
  ROL      A         3C    1     2      C << A      <<C       N......ZC
  ROL      dp        2B    2     4      C << (dp)   <<C       N......ZC
  ROL     dp+X       3B    2     5      C << (dp+X) <<C       N......ZC
  ROL     labs       2C    3     5      C << (abs)  <<C       N......ZC
-----------------------------------------------------------------------
  ROR      A         7C    1     2      C >> A      <<C       N......ZC
  ROR      dp        6B    2     4      C >> (dp)   <<C       N......ZC
  ROR     dp+X       7B    2     5      C >> (dp+X) <<C       N......ZC
  ROR     labs       6C    3     5      C >> (abs)  <<C       N......ZC
-----------------------------------------------------------------------
  XCN      A         9F    1     5      A(7-1) <-> A(3-0)     N......Z.
-----------------------------------------------------------------------
  
  8. 16-BIT TRANSMISSION COMMANDS

------------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
------------------------------------------------------------------------
  MOVW     YA,dp     BA    2     5     YA  - (dp+1)(dp)       N......Z.
  MOVW     dp,YA     DA    2     4    (dp+1)(dp) - YA         .........
-----------------------------------------------------------------------

9. 16-BIT OPERATION COMMANDS.

-----------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
-----------------------------------------------------------------------
  INCW     dp        3A    2     6  Increment dp memory pair  N......Z.
  DECW     dp        1A    2     6  Decrement dp memory pair  N......Z.
  ADDW    YA,dp      7A    2     5   YA  <- YA + (dp+1)(dp)   NV..H..ZC
  SUBW    YA,dp      9A    2     5   YA  <- YA - (dp+1)(dp)   NV..H..ZC
  CMPW    YA,dp      5A    2     4     YA - (dp+1)(dp)        N......Z.
-----------------------------------------------------------------------

10. MULTIPLICATION & DIVISION COMMANDS.

-----------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
-----------------------------------------------------------------------
  MUL      YA        CF    1     9    YA(16 bits) <- Y * A    N......Z.
  DIV      YA,X      9E    1    12    Q:A B:Y <- YA / X       NV..H..Z.
-----------------------------------------------------------------------  
  
11. DECIMAL COMPENSATION COMMANDS.
  
-----------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
-----------------------------------------------------------------------
  DAA       A        DF    1     3    decimal adjust for add  N......ZC
  DAS       A        BE    1     3    decimal adjust for sub  N......ZC
-----------------------------------------------------------------------

12. BRANCHING COMMANDS.            
  
-----------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
-----------------------------------------------------------------------
  BRA     rel        2F    2     4   branch always                  ...
  BEQ     rel        F0    2    2/4  branch on Z=1                  ...
  BNE     rel        D0    2    2/4  branch on Z=0                  ...
  BCS     rel        B0    2    2/4  branch on C=1                  ... 
  BCC     rel        90    2    2/4  branch on C=0                  ...
  BVS     rel        70    2    2/4  branch on V=1                  ...
  BVC     rel        50    2    2/4  branch on V=0                  ...
  BMI     rel        30    2    2/4  branch on N=1                  ...
  BPL     rel        10    2    2/4  branch on N=0                  ...
  BBS   dp.bit,rel   x3    3    5/7  branch on dp.bit=1             ...
  BBC   dp.bit,rel   y3    3    5/7  branch on dp.bit=0             ...
  CBNE   dp,rel      2E    3    5/7  compare A with (dp) then BNE   ...
  CBNE  dp+X,rel     DE    3    6/8  compare A with (dp+X) then BNE ...
  DBNZ   dp,rel      6E    3    5/7  decrement memory (dp) then JNZ ...
  DBNZ    Y,rel      FE    2    4/6  decrement Y then JNZ           ...
  JMP     labs       5F    3     3   jump to new location           ...
  JMP    (labs+X)    1F    3     6   PC <- (abs+X+1)(abs+X)         ...
-----------------------------------------------------------------------

13. SUB-ROUTINE CALL RETURN COMMANDS.

-----------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation               NVPBHIZC   
-----------------------------------------------------------------------
  CALL     labs      3F    3     8   subroutine call          ........ 
  PCALL   upage      4F    2     6   upage call               ........ 
  TCALL     n        n1    1     8   table call               ........ 
  BRK                0F    1     8   software interrupt       ...1.0.. 
                                                                       
  RET                6F    1     5   return from subroutine   ........ 
  RET1               7F    1     6   return from interrupt   (Restored)
-----------------------------------------------------------------------

14. STACK OPERATION COMMANDS.

-----------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
-----------------------------------------------------------------------
  PUSH      A        2D    1     4    push A to stack         .........
  PUSH      X        4D    1     4    push X to stack         .........
  PUSH      Y        6D    1     4    push Y to stack         .........
  PUSH     PSW       0D    1     4    push PSW to stack       .........
-----------------------------------------------------------------------  
  POP       A        AE    1     4    pop A from stack        .........
  POP       X        CE    1     4    pop X from stack        .........
  POP       Y        EE    1     4    pop Y from stack        .........
  POP      PSW       8E    1     4    pop PSW from stack     (Restored)
-----------------------------------------------------------------------  
  
15. BIT OPERATION COMMANDS.
  
-----------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
-----------------------------------------------------------------------
  SET1    dip.bit    x2    2     4  set direct page bit       .........
  CLR1    dip.bit    y2    2     4  clear direct page bit     .........
  
  TSET1    labs      0E    3     6 test and set bits with A   N......Z.
  TCLR1    labs      4E    3     6 test and clear bits with A N......Z.
  
  AND1   C,mem.bit   4A    3     4  C <- C AND (mem.bit)      ........C
  AND1   C,/mem.bit  6A    3     4  C <- C AND !(mem.bit)     ........C                 
  OR1    C,mem.bit   0A    3     5  C <- C OR  (mem.bit)      ........C               
  OR1    C,/mem.bit  2A    3     5  C <- C OR  !(mem.bit)     ........C                
  EOR1   C,mem.bit   8A    3     5  C <- C EOR (mem.bit)      ........C               
  NOT1   mem.bit     EA    3     5  complement (mem.bit)      .........                     
  MOV1   C,mem.bit   AA    3     4  C <- (mem.bit)            ........C          
  MOV1   mem.bit,C   CA    3     6  C -> (mem.bit)            ......... 
-----------------------------------------------------------------------

16. PROGRAM STATUS FLAG OPERATION COMMANDS.

-----------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                NVPBHIZC   
-----------------------------------------------------------------------
  CLRC               60    1     2   clear carry flag          .......0 
  SETC               80    1     2   set carry flag            .......1 
  NOTC               ED    1     3   complement carry flag     .......C 
  CLRV               E0    1     2   clear V and H             .0..0... 
  CLRP               20    1     2   clear direct page flag    ..0..... 
  SETP               40    1     2   set direct page flag      ..1..0..
  EI                 A0    1     3  set interrupt enable flag  .....1.. 
  DI                 C0    1     3 clear interrupt enable flag .....0..
-----------------------------------------------------------------------
  
17. OTHER COMMANDS.

-----------------------------------------------------------------------
Mnemonic  Operand   Code Bytes Cycles Operation                  Flag
-----------------------------------------------------------------------
  NOP                00    1     2    no operation            .........
  SLEEP              EF    1     3    standby SLEEP mode      .........
  STOP               FF    1     3    standby STOP mode       .........
-----------------------------------------------------------------------
